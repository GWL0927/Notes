# 获取设备信息

`Navigator`对象中的`userAgent` 属性是一个只读的字符串，声明了浏览器用于 HTTP 请求的用户代理头的值。

```js
console.log(navigator.userAgent)
// Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.1 Safari/605.1.15 
```

```js
// 会玩官网的env.js
const UA = navigator.userAgent

export const IS_DD = /DingTalk/i.test(UA)
export const IS_WECHAT = /micromessenger/i.test(UA)
export const IS_QQ = /QQTheme/.test(UA)
export const IS_IOS = /iphone|ipod|ipad/i.test(UA)
export const IS_ANDROID = /android/i.test(UA)
export const IS_MOBILE = /mobile/i.test(UA)

export const W = document.documentElement.clientWidth || document.body.clientWidth || window.innerWidth || window.screen.width
export const H = document.documentElement.clientHeight || document.body.clientHeight || window.innerHeight || window.screen.height

export default {
  IS_DD,
  IS_WECHAT,
  IS_QQ,
  IS_IOS,
  IS_ANDROID,
  IS_MOBILE
}
```

# 引入多个组件

**`require.context(directory,useSubdirectories,regExp)`**

- `directory`：表示检索的目录
- `useSubdirectories`：表示是否检索子文件夹
- `regExp`：匹配文件的正则表达式,一般是文件名

例如 `require.context("@/views/components",false,/.vue$/)`

1. 常常用来在组件内引入多个组件

   ```js
   const path = require('path')
   const files = require.context('@/components/home', false, /\.vue$/)
   const modules = {}
   files.keys().forEach(key => {
     const name = path.basename(key, '.vue')
     modules[name] = files(key).default || files(key)
   })
   export default{
       ...
       components:modules
   }
   ```

2. 在main.js中引入大量公共组件

   ```js
   import Vue from 'vue'
   // 自定义组件
   const requireComponents = require.context('../views/components', true, /\.vue/)
   // 打印结果
   // 遍历出每个组件的路径
   requireComponents.keys().forEach(fileName => {
     // 组件实例
     const reqCom = requireComponents(fileName)
     // 截取路径作为组件名
     const reqComName =reqCom.name|| fileName.replace(/\.\/(.*)\.vue/,'$1')
     // 组件挂载
     Vue.component(reqComName, reqCom.default || reqCom)
   })
   ```


# v-for中使用key

使用 `v-for` 更新已渲染的元素列表时，默认用就地复用策略；列表数据修改的时候，他会根据 `key` 值去判断某个值是否修改，如果修改，则重新渲染这一项，否则复用之前的元素；

使用key的注意事项：

- 不要使用可能重复的或者可能变化 `key` 值（控制台也会给出提醒）
- 如果数组中的数据有状态需要维持时（例如输入框），不要使用数组的 `index` 作为 `key` 值，因为如果在数组中插入或者移除一个元素时，其后面的元素 index 将会变化，这回让vue进行原地复用时错误的绑定状态。
- 如果数组中没有唯一的 key值可用，且数组更新时不是全量更新而是采用类似push，splice来插入或者移除数据时，可以考虑对其添加一个 key 字段，值为 Symbol() 即可保证唯一。

> 何时使用何种key？

vue 中的 **原地复用** （大概就是 `虚拟dom` 变化时，两个 `虚拟dom节点` 的 `key` 如果一样就不会重新创建节点，而是修改原来的节点）

当我们渲染的数据不需要保持状态时，例如常见的单纯的表格分页渲染（不包含输入，只是展示）、下拉加载更多等场景，那么使用 `index` 作为 `key` 再好不过，因为进入下一页或者上一页时就会原地复用之前的节点，而不是重新创建，如果使用唯一的 `id` 作为 `key` 反而会重新创建dom，性能相对较低。

此外使用 `index` 作为 `key` 我还应该要尽量避免对数组的中间进行 增加/删除 等会影响后面元素key变化的操作。这会让 vue 认为后面所有元素都发生了变化，导致多余的对比和原地复用。

使用 index 作为 key 需要满足：

1. 数据没有独立的状态
2. 数据不会进行 增加/删除 等会影响后面元素key变化的操作

# Console.log的坑

**打印出来，展开后，不是代码当前位置的对象值，是代码执行完后的对象值**

控制台输出信息：

![img](https://img.jbzj.com/file_images/article/201905/201905230942451.png)

咋一看，没问题，输出的结果的确是我们传入时的样子。但实际中，传入的对象可能具有很多属性，那么我们想要看完整的信息就必须将输出结果展开。如下：

![img](https://img.jbzj.com/file_images/article/201905/201905230942452.png)

分析如下：

根据js的单线程特性，按理说对obj对象修改之前和之后二则打印的结果会不同，但实际结果却相同。

**说明在浏览器打印对象时，并未去直接调用对象所对应的堆内存中的值**，而是首先打印了个此刻浏览器自己解析的一个代表这个对象的一个字符串。当我们点击这个值，**去展开这个对象时，浏览器才会去根据这个对象的引用地址去堆内存中获取对象**。

由于展开 `console.log()` 的结果并不是我们代码所处位置那个时间点的对象的拷贝，故我们想要在代码执行到那个位置时的那个时间点对应的对象状态，只要在那时输出 **对象的副本** 即可。

`console.log({ ...obj })`

## 实例

[<img src="https://s4.ax1x.com/2022/01/19/7r5r4S.png" alt="7r5r4S.png" style="zoom:50%;" />](https://imgtu.com/i/7r5r4S)

编辑话题确认按钮，调用接口时`this.editInfo`获取的是当前表单值，而在上面打印`this.editInfo`时，表单值是空的，一度以为是editInfo值没绑定上，后面才知道，`console.log`的机制（打印代码执行完后的对象值），因为在后面执行了`resetFields()`清空了表单，所以打印出来表单值是空的

# v-model和v-bind.sync

## v-model

在自定义组件中

```xml
<base-checkbox v-model="value"></base-checkbox> 
```

相当于

```vue
<base-checkbox :value="value" @input="value = argument"></base-checkbox> // 父组件
```

一个组件上的 `v-model` 默认会利用名为 `value` 的 prop 和名为 `input` 的事件，但是像单选框、复选框等类型的输入控件可能会将 `value` attribute 用于不同的目的。`model` 选项可以用来避免这样的冲突：

```vue
<base-checkbox v-model="value"></base-checkbox>
<script>
Vue.component('base-checkbox', {
  model: {
    prop: 'checked',
    event: 'change'
  },
  props: {
    checked: Boolean
  },
  template: `
    <input
      type="checkbox"
      v-bind:checked="checked"
      v-on:change="$emit('change', $event.target.checked)"
    >
  `
})
</script>
```

## v-bind.sync

作用：.sync修饰符可以自动更新父组件属性的v-on，当子组件改变了prop的值时，会将这个变化同步到父组件。

本质：.sync也是一个语法糖，sync修饰符的控制能在都在父组件，事件名称也是固定的update:xxx，需要和.sync前面的变量名对应起来。

自定义组件：

```vue
<custom-component :value.sync="value"></custom-component>
```

相当于：

```vue
<custom-component :value="value" @update:value="value = $event"></custom-component> 
```

当子组件需要更新value的值时，需要显示的触发一个更新事件：

```js
this.$emit('update:value', newVal) 
```

## 两者的区别

1. v-model默认对应的是input标签的input事件，如果在子组件中用`model: {}`来替换了这个事件，其本质和.sync修饰符一样。

   ```js
   model: {
     prop: 'value',
     event: 'update'
   }
   ```

2. 一个组件只能用一个v-model，但可以有多个属性使用.sync修饰符，同时双向绑定多个prop

## 总结

- `v-model="xxx"`相当于 `v-bind:value="xxx"` ` v-on:input="xxx"`，

  子组件prop为value，向父组件传递input事件`this.$emit('input', val)`

- `v-bind:任意名.sync="xxx"` 相当于`v-bind:任意名="xxx"` ` v-on:update:my-event=""`，

  子组件prop为任意名，向父组件传递my-event事件 `this.$emit('update:my-event', val)`

# v-on.native

在一个组件的根元素上直接监听一个原生事件。这时，可以使用`v-on`的`.native`	修饰符：

```html
<base-input v-on:focus.native="onFocus"></base-input>
```

`<base-input>` 组件可能做了如下重构，所以根元素实际上是一个 `<label>` 元素：

```vue
// base-input.vue
<label>
  {{ label }}
  <input
    v-bind="$attrs"
    v-bind:value="value"
    v-on:input="$emit('input', $event.target.value)"
  >
</label>
```

这时，父级的 `.native` 监听器将静默失败。它不会产生任何报错，但是 `onFocus` 处理函数不会如你预期地被调用。

**Vue提供了一个`$listeners`property，它是一个对象，里面包含了这个组件上的所有监听器。**例如：

```js
{
  focus: function (event) { /* ... */ }
  input: function (value) { /* ... */ },
  ......
}
```

## 如何不用.native

解决子组件根元素不是 `<input>`的问题

对于类似 `<input>` 的你希望它也可以配合 `v-model` 工作的组件来说，为这些监听器创建一个类似下述 `inputListeners` 的计算属性通常是非常有用的： **相当于将所有监听器放到一个计算属性中，然后给组件的`<input>`用`v-on="{ ... ... }"`全部绑定上**

```js
Vue.component('base-input', {
  inheritAttrs: false, // 不希望组件的根元素继承特性
  props: ['label', 'value'],
  computed: {
    inputListeners: function () {
      var vm = this
      // `Object.assign` 将所有的对象合并为一个新对象
      return Object.assign({},
        // 我们从父级添加所有的监听器
        this.$listeners,
        // 然后我们添加自定义监听器，或覆写一些监听器的行为
        ......
        { // 这里确保组件配合 `v-model` 的工作
          input: function (event) {
            vm.$emit('input', event.target.value)
          }
        }
      )
    }
  },
  template: `
    <label>
      {{ label }}
      <input
        v-bind="$attrs"
        v-bind:value="value"
        v-on="inputListeners"
      >
    </label>
  `
})
```

现在 `<base-input>` 组件是一个**完全透明的包裹器**了，也就是说它可以完全像一个普通的 `<input>` 元素一样使用了：所有跟它相同的 attribute 和监听器都可以工作，不必再使用 `.native` 监听器。

